function RoughSegmentRelation(){return{LEFT:0,RIGHT:1,INTERSECTS:2,AHEAD:3,BEHIND:4,SEPARATE:5,UNDEFINED:6}}class RoughSegment{constructor(t,e,s,i){this.RoughSegmentRelationConst=RoughSegmentRelation(),this.px1=t,this.py1=e,this.px2=s,this.py2=i,this.xi=Number.MAX_VALUE,this.yi=Number.MAX_VALUE,this.a=i-e,this.b=t-s,this.c=s*e-t*i,this._undefined=0==this.a&&0==this.b&&0==this.c}isUndefined(){return this._undefined}compare(t){if(this.isUndefined()||t.isUndefined())return this.RoughSegmentRelationConst.UNDEFINED;var e=Number.MAX_VALUE,s=Number.MAX_VALUE,i=0,h=0,a=this.a,n=this.b,o=this.c;return Math.abs(n)>1e-5&&(e=-a/n,i=-o/n),Math.abs(t.b)>1e-5&&(s=-t.a/t.b,h=-t.c/t.b),e==Number.MAX_VALUE?s==Number.MAX_VALUE?-o/a!=-t.c/t.a?this.RoughSegmentRelationConst.SEPARATE:this.py1>=Math.min(t.py1,t.py2)&&this.py1<=Math.max(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,this.RoughSegmentRelationConst.INTERSECTS):this.py2>=Math.min(t.py1,t.py2)&&this.py2<=Math.max(t.py1,t.py2)?(this.xi=this.px2,this.yi=this.py2,this.RoughSegmentRelationConst.INTERSECTS):this.RoughSegmentRelationConst.SEPARATE:(this.xi=this.px1,this.yi=s*this.xi+h,(this.py1-this.yi)*(this.yi-this.py2)<-1e-5||(t.py1-this.yi)*(this.yi-t.py2)<-1e-5?this.RoughSegmentRelationConst.SEPARATE:Math.abs(t.a)<1e-5&&(t.px1-this.xi)*(this.xi-t.px2)<-1e-5?this.RoughSegmentRelationConst.SEPARATE:this.RoughSegmentRelationConst.INTERSECTS):s==Number.MAX_VALUE?(this.xi=t.px1,this.yi=e*this.xi+i,(t.py1-this.yi)*(this.yi-t.py2)<-1e-5||(this.py1-this.yi)*(this.yi-this.py2)<-1e-5?this.RoughSegmentRelationConst.SEPARATE:Math.abs(a)<1e-5&&(this.px1-this.xi)*(this.xi-this.px2)<-1e-5?this.RoughSegmentRelationConst.SEPARATE:this.RoughSegmentRelationConst.INTERSECTS):e==s?i!=h?this.RoughSegmentRelationConst.SEPARATE:this.px1>=Math.min(t.px1,t.px2)&&this.px1<=Math.max(t.py1,t.py2)?(this.xi=this.px1,this.yi=this.py1,this.RoughSegmentRelationConst.INTERSECTS):this.px2>=Math.min(t.px1,t.px2)&&this.px2<=Math.max(t.px1,t.px2)?(this.xi=this.px2,this.yi=this.py2,this.RoughSegmentRelationConst.INTERSECTS):this.RoughSegmentRelationConst.SEPARATE:(this.xi=(h-i)/(e-s),this.yi=e*this.xi+i,(this.px1-this.xi)*(this.xi-this.px2)<-1e-5||(t.px1-this.xi)*(this.xi-t.px2)<-1e-5?this.RoughSegmentRelationConst.SEPARATE:this.RoughSegmentRelationConst.INTERSECTS)}getLength(){return this._getLength(this.px1,this.py1,this.px2,this.py2)}_getLength(t,e,s,i){var h=s-t,a=i-e;return Math.sqrt(h*h+a*a)}}class RoughHachureIterator{constructor(t,e,s,i,h,a,n,o){this.top=t,this.bottom=e,this.left=s,this.right=i,this.gap=h,this.sinAngle=a,this.tanAngle=o,Math.abs(a)<1e-4?this.pos=s+h:Math.abs(a)>.9999?this.pos=t+h:(this.deltaX=(e-t)*Math.abs(o),this.pos=s-Math.abs(this.deltaX),this.hGap=Math.abs(h/n),this.sLeft=new RoughSegment(s,e,s,t),this.sRight=new RoughSegment(i,e,i,t))}getNextLine(){if(Math.abs(this.sinAngle)<1e-4){if(this.pos<this.right){let t=[this.pos,this.top,this.pos,this.bottom];return this.pos+=this.gap,t}}else if(Math.abs(this.sinAngle)>.9999){if(this.pos<this.bottom){let t=[this.left,this.pos,this.right,this.pos];return this.pos+=this.gap,t}}else{let t=this.pos-this.deltaX/2,e=this.pos+this.deltaX/2,s=this.bottom,i=this.top;if(this.pos<this.right+this.deltaX){for(;t<this.left&&e<this.left||t>this.right&&e>this.right;)if(this.pos+=this.hGap,t=this.pos-this.deltaX/2,e=this.pos+this.deltaX/2,this.pos>this.right+this.deltaX)return null;let h=new RoughSegment(t,s,e,i);h.compare(this.sLeft)==RoughSegmentRelation().INTERSECTS&&(t=h.xi,s=h.yi),h.compare(this.sRight)==RoughSegmentRelation().INTERSECTS&&(e=h.xi,i=h.yi),this.tanAngle>0&&(t=this.right-(t-this.left),e=this.right-(e-this.left));let a=[t,s,e,i];return this.pos+=this.hGap,a}}return null}}class PathToken{constructor(t,e){this.type=t,this.text=e}isType(t){return this.type===t}}class ParsedPath{constructor(t){this.PARAMS={A:["rx","ry","x-axis-rotation","large-arc-flag","sweep-flag","x","y"],a:["rx","ry","x-axis-rotation","large-arc-flag","sweep-flag","x","y"],C:["x1","y1","x2","y2","x","y"],c:["x1","y1","x2","y2","x","y"],H:["x"],h:["x"],L:["x","y"],l:["x","y"],M:["x","y"],m:["x","y"],Q:["x1","y1","x","y"],q:["x1","y1","x","y"],S:["x2","y2","x","y"],s:["x2","y2","x","y"],T:["x","y"],t:["x","y"],V:["y"],v:["y"],Z:[],z:[]},this.COMMAND=0,this.NUMBER=1,this.EOD=2,this.segments=[],this.d=t||"",this.parseData(t),this.processPoints()}loadFromSegments(t){this.segments=t,this.processPoints()}processPoints(){let t=null,e=[0,0];for(let s=0;s<this.segments.length;s++){let i=this.segments[s];switch(i.key){case"M":case"L":case"T":i.point=[i.data[0],i.data[1]];break;case"m":case"l":case"t":i.point=[i.data[0]+e[0],i.data[1]+e[1]];break;case"H":i.point=[i.data[0],e[1]];break;case"h":i.point=[i.data[0]+e[0],e[1]];break;case"V":i.point=[e[0],i.data[0]];break;case"v":i.point=[e[0],i.data[0]+e[1]];break;case"z":case"Z":t&&(i.point=[t[0],t[1]]);break;case"C":i.point=[i.data[4],i.data[5]];break;case"c":i.point=[i.data[4]+e[0],i.data[5]+e[1]];break;case"S":i.point=[i.data[2],i.data[3]];break;case"s":i.point=[i.data[2]+e[0],i.data[3]+e[1]];break;case"Q":i.point=[i.data[2],i.data[3]];break;case"q":i.point=[i.data[2]+e[0],i.data[3]+e[1]];break;case"A":i.point=[i.data[5],i.data[6]];break;case"a":i.point=[i.data[5]+e[0],i.data[6]+e[1]]}"m"!==i.key&&"M"!==i.key||(t=null),i.point&&(e=i.point,t||(t=i.point)),"z"!==i.key&&"Z"!==i.key||(t=null)}}get closed(){if(void 0===this._closed){this._closed=!1;for(let t of this.segments)"z"===t.key.toLowerCase()&&(this._closed=!0)}return this._closed}parseData(t){var e=this.tokenize(t),s=0,i=e[s],h="BOD";for(this.segments=new Array;!i.isType(this.EOD);){var a,n=new Array;if("BOD"==h){if("M"!=i.text&&"m"!=i.text)return this.parseData("M0,0"+t);s++,a=this.PARAMS[i.text].length,h=i.text}else i.isType(this.NUMBER)?a=this.PARAMS[h].length:(s++,a=this.PARAMS[i.text].length,h=i.text);if(s+a<e.length){for(var o=s;o<s+a;o++){var r=e[o];if(!r.isType(this.NUMBER))return void console.error("Parameter type is not a number: "+h+","+r.text);n[n.length]=r.text}var l;if(!this.PARAMS[h])return void console.error("Unsupported segment type: "+h);l={key:h,data:n},this.segments.push(l),i=e[s+=a],"M"==h&&(h="L"),"m"==h&&(h="l")}else console.error("Path data ended before all parameters were found")}}tokenize(t){for(var e=new Array;""!=t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]=new PathToken(this.COMMAND,RegExp.$1),t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return console.error("Unrecognized segment command: "+t),null;e[e.length]=new PathToken(this.NUMBER,parseFloat(RegExp.$1)),t=t.substr(RegExp.$1.length)}return e[e.length]=new PathToken(this.EOD,null),e}}class RoughPath{constructor(t){this.d=t,this.parsed=new ParsedPath(t),this._position=[0,0],this.bezierReflectionPoint=null,this.quadReflectionPoint=null,this._first=null}get segments(){return this.parsed.segments}get closed(){return this.parsed.closed}get linearPoints(){if(!this._linearPoints){const t=[];let e=[];for(let s of this.parsed.segments){let i=s.key.toLowerCase();("m"!==i&&"z"!==i||(e.length&&(t.push(e),e=[]),"z"!==i))&&(s.point&&e.push(s.point))}e.length&&(t.push(e),e=[]),this._linearPoints=t}return this._linearPoints}get first(){return this._first}set first(t){this._first=t}setPosition(t,e){this._position=[t,e],this._first||(this._first=[t,e])}get position(){return this._position}get x(){return this._position[0]}get y(){return this._position[1]}}class RoughArcConverter{constructor(t,e,s,i,h,a){const n=Math.PI/180;if(this._segIndex=0,this._numSegs=0,t[0]==e[0]&&t[1]==e[1])return;this._rx=Math.abs(s[0]),this._ry=Math.abs(s[1]),this._sinPhi=Math.sin(i*n),this._cosPhi=Math.cos(i*n);var o,r=this._cosPhi*(t[0]-e[0])/2+this._sinPhi*(t[1]-e[1])/2,l=-this._sinPhi*(t[0]-e[0])/2+this._cosPhi*(t[1]-e[1])/2,g=this._rx*this._rx*this._ry*this._ry-this._rx*this._rx*l*l-this._ry*this._ry*r*r;if(g<0){let t=Math.sqrt(1-g/(this._rx*this._rx*this._ry*this._ry));this._rx=this._rx*t,this._ry=this._ry*t,o=0}else o=(h==a?-1:1)*Math.sqrt(g/(this._rx*this._rx*l*l+this._ry*this._ry*r*r));let p=o*this._rx*l/this._ry,f=-o*this._ry*r/this._rx;this._C=[0,0],this._C[0]=this._cosPhi*p-this._sinPhi*f+(t[0]+e[0])/2,this._C[1]=this._sinPhi*p+this._cosPhi*f+(t[1]+e[1])/2,this._theta=this.calculateVectorAngle(1,0,(r-p)/this._rx,(l-f)/this._ry);let c=this.calculateVectorAngle((r-p)/this._rx,(l-f)/this._ry,(-r-p)/this._rx,(-l-f)/this._ry);!a&&c>0?c-=2*Math.PI:a&&c<0&&(c+=2*Math.PI),this._numSegs=Math.ceil(Math.abs(c/(Math.PI/2))),this._delta=c/this._numSegs,this._T=8/3*Math.sin(this._delta/4)*Math.sin(this._delta/4)/Math.sin(this._delta/2),this._from=t}getNextSegment(){var t,e,s;if(this._segIndex==this._numSegs)return null;let i=Math.cos(this._theta),h=Math.sin(this._theta),a=this._theta+this._delta,n=Math.cos(a),o=Math.sin(a);return s=[this._cosPhi*this._rx*n-this._sinPhi*this._ry*o+this._C[0],this._sinPhi*this._rx*n+this._cosPhi*this._ry*o+this._C[1]],t=[this._from[0]+this._T*(-this._cosPhi*this._rx*h-this._sinPhi*this._ry*i),this._from[1]+this._T*(-this._sinPhi*this._rx*h+this._cosPhi*this._ry*i)],e=[s[0]+this._T*(this._cosPhi*this._rx*o+this._sinPhi*this._ry*n),s[1]+this._T*(this._sinPhi*this._rx*o-this._cosPhi*this._ry*n)],this._theta=a,this._from=[s[0],s[1]],this._segIndex++,{cp1:t,cp2:e,to:s}}calculateVectorAngle(t,e,s,i){let h=Math.atan2(e,t),a=Math.atan2(i,s);return a>=h?a-h:2*Math.PI-(h-a)}}class RoughRenderer{hachureFillShape(t,e,s){let i=[];if(t&&e&&t.length&&e.length){let h=t[0],a=t[0],n=e[0],o=e[0];for(let s=1;s<t.length;s++)h=Math.min(h,t[s]),a=Math.max(a,t[s]),n=Math.min(n,e[s]),o=Math.max(o,e[s]);const r=s.hachureAngle;let l=s.hachureGap;l<0&&(l=4*s.strokeWidth),l=Math.max(l,.1);const g=r%180*(Math.PI/180),p=Math.cos(g),f=Math.sin(g),c=Math.tan(g),u=new RoughHachureIterator(n-1,o+1,h-1,a+1,l,f,p,c);let d;for(;null!=(d=u.getNextLine());){let h=this._getIntersectingLines(d,t,e);for(let t=0;t<h.length;t++)if(t<h.length-1){let e=h[t],a=h[t+1];i=i.concat(this._doubleLine(e[0],e[1],a[0],a[1],s))}}}return{type:"fillSketch",ops:i}}svgPath(t,e){t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");let s=new RoughPath(t);if(e.simplification){let t=new PathFitter(s.linearPoints,s.closed).fit(e.simplification);s=new RoughPath(t)}let i=[],h=s.segments||[];for(let t=0;t<h.length;t++){let a=h[t],n=t>0?h[t-1]:null,o=this._processSegment(s,a,n,e);o&&o.length&&(i=i.concat(o))}return{type:"path",ops:i}}_bezierTo(t,e,s,i,h,a,n,o){let r=[],l=[o.maxRandomnessOffset||1,(o.maxRandomnessOffset||1)+.5],g=null;for(let p=0;p<2;p++)0===p?r.push({op:"move",data:[n.x,n.y]}):r.push({op:"move",data:[n.x+this._getOffset(-l[0],l[0],o),n.y+this._getOffset(-l[0],l[0],o)]}),g=[h+this._getOffset(-l[p],l[p],o),a+this._getOffset(-l[p],l[p],o)],r.push({op:"bcurveTo",data:[t+this._getOffset(-l[p],l[p],o),e+this._getOffset(-l[p],l[p],o),s+this._getOffset(-l[p],l[p],o),i+this._getOffset(-l[p],l[p],o),g[0],g[1]]});return n.setPosition(g[0],g[1]),r}_processSegment(t,e,s,i){let h=[];switch(e.key){case"M":case"m":{let s="m"===e.key;if(e.data.length>=2){let a=+e.data[0],n=+e.data[1];s&&(a+=t.x,n+=t.y);let o=1*(i.maxRandomnessOffset||0);a+=this._getOffset(-o,o,i),n+=this._getOffset(-o,o,i),t.setPosition(a,n),h.push({op:"move",data:[a,n]})}break}case"L":case"l":{let s="l"===e.key;if(e.data.length>=2){let a=+e.data[0],n=+e.data[1];s&&(a+=t.x,n+=t.y),h=h.concat(this._doubleLine(t.x,t.y,a,n,i)),t.setPosition(a,n)}break}case"H":case"h":{const s="h"===e.key;if(e.data.length){let a=+e.data[0];s&&(a+=t.x),h=h.concat(this._doubleLine(t.x,t.y,a,t.y,i)),t.setPosition(a,t.y)}break}case"V":case"v":{const s="v"===e.key;if(e.data.length){let a=+e.data[0];s&&(a+=t.y),h=h.concat(this._doubleLine(t.x,t.y,t.x,a,i)),t.setPosition(t.x,a)}break}case"Z":case"z":t.first&&(h=h.concat(this._doubleLine(t.x,t.y,t.first[0],t.first[1],i)),t.setPosition(t.first[0],t.first[1]),t.first=null);break;case"C":case"c":{const s="c"===e.key;if(e.data.length>=6){let a=+e.data[0],n=+e.data[1],o=+e.data[2],r=+e.data[3],l=+e.data[4],g=+e.data[5];s&&(a+=t.x,o+=t.x,l+=t.x,n+=t.y,r+=t.y,g+=t.y);let p=this._bezierTo(a,n,o,r,l,g,t,i);h=h.concat(p),t.bezierReflectionPoint=[l+(l-o),g+(g-r)]}break}case"S":case"s":{const n="s"===e.key;if(e.data.length>=4){let o=+e.data[0],r=+e.data[1],l=+e.data[2],g=+e.data[3];n&&(o+=t.x,l+=t.x,r+=t.y,g+=t.y);let p=o,f=r,c=s?s.key:"";var a=null;"c"!=c&&"C"!=c&&"s"!=c&&"S"!=c||(a=t.bezierReflectionPoint),a&&(p=a[0],f=a[1]);let u=this._bezierTo(p,f,o,r,l,g,t,i);h=h.concat(u),t.bezierReflectionPoint=[l+(l-o),g+(g-r)]}break}case"Q":case"q":{const s="q"===e.key;if(e.data.length>=4){let a=+e.data[0],n=+e.data[1],o=+e.data[2],r=+e.data[3];s&&(a+=t.x,o+=t.x,n+=t.y,r+=t.y);let l=1*(1+.2*i.roughness),g=1.5*(1+.22*i.roughness);h.push({op:"move",data:[t.x+this._getOffset(-l,l,i),t.y+this._getOffset(-l,l,i)]});let p=[o+this._getOffset(-l,l,i),r+this._getOffset(-l,l,i)];h.push({op:"qcurveTo",data:[a+this._getOffset(-l,l,i),n+this._getOffset(-l,l,i),p[0],p[1]]}),h.push({op:"move",data:[t.x+this._getOffset(-g,g,i),t.y+this._getOffset(-g,g,i)]}),p=[o+this._getOffset(-g,g,i),r+this._getOffset(-g,g,i)],h.push({op:"qcurveTo",data:[a+this._getOffset(-g,g,i),n+this._getOffset(-g,g,i),p[0],p[1]]}),t.setPosition(p[0],p[1]),t.quadReflectionPoint=[o+(o-a),r+(r-n)]}break}case"T":case"t":{const n="t"===e.key;if(e.data.length>=2){let o=+e.data[0],r=+e.data[1];n&&(o+=t.x,r+=t.y);let l=o,g=r,p=s?s.key:"";a=null;"q"!=p&&"Q"!=p&&"t"!=p&&"T"!=p||(a=t.quadReflectionPoint),a&&(l=a[0],g=a[1]);let f=1*(1+.2*i.roughness),c=1.5*(1+.22*i.roughness);h.push({op:"move",data:[t.x+this._getOffset(-f,f,i),t.y+this._getOffset(-f,f,i)]});let u=[o+this._getOffset(-f,f,i),r+this._getOffset(-f,f,i)];h.push({op:"qcurveTo",data:[l+this._getOffset(-f,f,i),g+this._getOffset(-f,f,i),u[0],u[1]]}),h.push({op:"move",data:[t.x+this._getOffset(-c,c,i),t.y+this._getOffset(-c,c,i)]}),u=[o+this._getOffset(-c,c,i),r+this._getOffset(-c,c,i)],h.push({op:"qcurveTo",data:[l+this._getOffset(-c,c,i),g+this._getOffset(-c,c,i),u[0],u[1]]}),t.setPosition(u[0],u[1]),t.quadReflectionPoint=[o+(o-l),r+(r-g)]}break}case"A":case"a":{const s="a"===e.key;if(e.data.length>=7){let a=+e.data[0],n=+e.data[1],o=+e.data[2],r=+e.data[3],l=+e.data[4],g=+e.data[5],p=+e.data[6];if(s&&(g+=t.x,p+=t.y),g==t.x&&p==t.y)break;if(0==a||0==n)h=h.concat(this._doubleLine(t.x,t.y,g,p,i)),t.setPosition(g,p);else{i.maxRandomnessOffset;for(let e=0;e<1;e++){let e=new RoughArcConverter([t.x,t.y],[g,p],[a,n],o,!!r,!!l),s=e.getNextSegment();for(;s;){let a=this._bezierTo(s.cp1[0],s.cp1[1],s.cp2[0],s.cp2[1],s.to[0],s.to[1],t,i);h=h.concat(a),s=e.getNextSegment()}}}}break}}return h}_getOffset(t,e,s){return s.roughness*(Math.random()*(e-t)+t)}_doubleLine(t,e,s,i,h){const a=this._line(t,e,s,i,h,!0,!1),n=this._line(t,e,s,i,h,!0,!0);return a.concat(n)}_line(t,e,s,i,h,a,n){const o=Math.pow(t-s,2)+Math.pow(e-i,2);let r=h.maxRandomnessOffset||0;r*r*100>o&&(r=Math.sqrt(o)/10);const l=r/2,g=.2+.2*Math.random();let p=h.bowing*h.maxRandomnessOffset*(i-e)/200,f=h.bowing*h.maxRandomnessOffset*(t-s)/200;p=this._getOffset(-p,p,h),f=this._getOffset(-f,f,h);let c=[];return a&&(n?c.push({op:"move",data:[t+this._getOffset(-l,l,h),e+this._getOffset(-l,l,h)]}):c.push({op:"move",data:[t+this._getOffset(-r,r,h),e+this._getOffset(-r,r,h)]})),n?c.push({op:"bcurveTo",data:[p+t+(s-t)*g+this._getOffset(-l,l,h),f+e+(i-e)*g+this._getOffset(-l,l,h),p+t+2*(s-t)*g+this._getOffset(-l,l,h),f+e+2*(i-e)*g+this._getOffset(-l,l,h),s+this._getOffset(-l,l,h),i+this._getOffset(-l,l,h)]}):c.push({op:"bcurveTo",data:[p+t+(s-t)*g+this._getOffset(-r,r,h),f+e+(i-e)*g+this._getOffset(-r,r,h),p+t+2*(s-t)*g+this._getOffset(-r,r,h),f+e+2*(i-e)*g+this._getOffset(-r,r,h),s+this._getOffset(-r,r,h),i+this._getOffset(-r,r,h)]}),c}_getIntersectingLines(t,e,s){let i=[];for(var h=new RoughSegment(t[0],t[1],t[2],t[3]),a=0;a<e.length;a++){let t=new RoughSegment(e[a],s[a],e[(a+1)%e.length],s[(a+1)%e.length]);h.compare(t)==RoughSegmentRelation().INTERSECTS&&i.push([h.xi,h.yi])}return i}}self._roughScript=self.document&&self.document.currentScript&&self.document.currentScript.src;class RoughGenerator{constructor(t,e){this.config=t||{},this.canvas=e,this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveStepCount:9,fill:null,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1},this.config.options&&(this.defaultOptions=this._options(this.config.options))}_options(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_drawable(t,e,s){return{shape:t,sets:e||[],options:s||this.defaultOptions}}get lib(){return this._renderer||(this._renderer=new RoughRenderer),this._renderer}path(t,e){const s=this._options(e),i=[];if(!t)return this._drawable("path",i,s);if(s.fill)if("solid"===s.fillStyle){let e={type:"path2Dfill",path:t};i.push(e)}else{const e=this._computePathSize(t);let h=[0,e[0],e[0],0],a=[0,0,e[1],e[1]],n=this.lib.hachureFillShape(h,a,s);n.type="path2Dpattern",n.size=e,n.path=t,i.push(n)}return i.push(this.lib.svgPath(t,s)),this._drawable("path",i,s)}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,i=[];for(const t of e){let e=null;switch(t.type){case"path":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:"none"};break;case"fillPath":e={d:this.opsToPath(t),stroke:"none",strokeWidth:0,fill:s.fill};break;case"fillSketch":e=this._fillSketch(t,s);break;case"path2Dfill":e={d:t.path,stroke:"none",strokeWidth:0,fill:s.fill};break;case"path2Dpattern":{const i=t.size,h={x:0,y:0,width:1,height:1,viewBox:`0 0 ${Math.round(i[0])} ${Math.round(i[1])}`,patternUnits:"objectBoundingBox",path:this._fillSketch(t,s)};e={d:t.path,stroke:"none",strokeWidth:0,pattern:h};break}}e&&i.push(e)}return i}_fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill,strokeWidth:s,fill:"none"}}opsToPath(t){let e="";for(let s of t.ops){const t=s.data;switch(s.op){case"move":e+=`M${t[0]} ${t[1]} `;break;case"bcurveTo":e+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case"qcurveTo":e+=`Q${t[0]} ${t[1]}, ${t[2]} ${t[3]} `;break;case"lineTo":e+=`L${t[0]} ${t[1]} `}}return e.trim()}_computePathSize(t){let e=[0,0];if(self.document)try{const s="http://www.w3.org/2000/svg";let i=self.document.createElementNS(s,"svg");i.setAttribute("width","0"),i.setAttribute("height","0");let h=self.document.createElementNS(s,"path");h.setAttribute("d",t),i.appendChild(h),self.document.body.appendChild(i);let a=h.getBBox();a&&(e[0]=a.width||0,e[1]=a.height||0),self.document.body.removeChild(i)}catch(t){}const s=this._canvasSize();return e[0]*e[1]||(e=s),e[0]=Math.min(e[0],s[0]),e[1]=Math.min(e[1],s[1]),e}_canvasSize(){const t=t=>t&&"object"==typeof t&&t.baseVal&&t.baseVal.value?t.baseVal.value:t||100;return this.canvas?[t(this.canvas.width),t(this.canvas.height)]:[100,100]}}class RoughSVG{constructor(t,e){this.svg=t,this._init(e)}_init(t){this.gen=new RoughGenerator(t,this.svg)}get generator(){return this.gen}get defs(){if(!this._defs){let t=(this.svg.ownerDocument||document).createElementNS("http://www.w3.org/2000/svg","defs");this.svg.firstChild?this.svg.insertBefore(t,this.svg.firstChild):this.svg.appendChild(t),this._defs=t}return this._defs}path(t,e){let s=this.gen.path(t,e);return this.draw(s)}draw(t){let e=t.sets||[],s=t.options||this.gen.defaultOptions,i=this.svg.ownerDocument||document,h=i.createElementNS("http://www.w3.org/2000/svg","g");for(let t of e){let e=null;switch(t.type){case"path":(e=i.createElementNS("http://www.w3.org/2000/svg","path")).setAttribute("d",this._opsToPath(t)),e.style.stroke=s.stroke,e.style.strokeWidth=s.strokeWidth,e.style.fill="none";break;case"fillPath":(e=i.createElementNS("http://www.w3.org/2000/svg","path")).setAttribute("d",this._opsToPath(t)),e.style.stroke="none",e.style.strokeWidth=0,e.style.fill=s.fill;break;case"fillSketch":e=this._fillSketch(i,t,s);break;case"path2Dfill":(e=i.createElementNS("http://www.w3.org/2000/svg","path")).setAttribute("d",t.path),e.style.stroke="none",e.style.strokeWidth=0,e.style.fill=s.fill;break;case"path2Dpattern":{const h=t.size,a=i.createElementNS("http://www.w3.org/2000/svg","pattern"),n=`rough-${Math.floor(Math.random()*(Number.MAX_SAFE_INTEGER||999999))}`;a.setAttribute("id",n),a.setAttribute("x",0),a.setAttribute("y",0),a.setAttribute("width",1),a.setAttribute("height",1),a.setAttribute("height",1),a.setAttribute("viewBox",`0 0 ${Math.round(h[0])} ${Math.round(h[1])}`),a.setAttribute("patternUnits","objectBoundingBox");const o=this._fillSketch(i,t,s);a.appendChild(o),this.defs.appendChild(a),(e=i.createElementNS("http://www.w3.org/2000/svg","path")).setAttribute("d",t.path),e.style.stroke="none",e.style.strokeWidth=0,e.style.fill=`url(#${n})`;break}}e&&h.appendChild(e)}return h}_fillSketch(t,e,s){let i=s.fillWeight;i<0&&(i=s.strokeWidth/2);let h=t.createElementNS("http://www.w3.org/2000/svg","path");return h.setAttribute("d",this._opsToPath(e)),h.style.stroke=s.fill,h.style.strokeWidth=i,h.style.fill="none",h}_opsToPath(t){return this.gen.opsToPath(t)}}
